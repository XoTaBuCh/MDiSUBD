DROP TABLE STUDENTS;
DROP TABLE GROUPS;
DROP TABLE LOGS;
CREATE TABLE GROUPS
(
    ID    NUMBER PRIMARY KEY NOT NULL,
    NAME  VARCHAR2(100)      NOT NULL,
    C_VAL NUMBER
);

CREATE TABLE STUDENTS
(
    ID       NUMBER PRIMARY KEY,
    NAME     VARCHAR2(100),
    GROUP_ID NUMBER
);
--------
DROP SEQUENCE STUDENTS_SEQ;
DROP SEQUENCE GROUPS_SEQ;

CREATE SEQUENCE STUDENTS_SEQ
    START WITH 1;

CREATE SEQUENCE GROUPS_SEQ
    START WITH 1;

CREATE OR REPLACE TRIGGER before_insert_students_trigger
    BEFORE INSERT
    ON STUDENTS
    FOR EACH ROW
BEGIN
    :new.ID := STUDENTS_SEQ.NEXTVAL;
END;


CREATE OR REPLACE TRIGGER before_insert_groups_trigger
    BEFORE INSERT
    ON GROUPS
    FOR EACH ROW
DECLARE
    flag NUMBER;
    name_taken EXCEPTION;
BEGIN
    IF INSERTING THEN
        SELECT GROUPS_SEQ.NEXTVAL INTO :new.ID FROM DUAL;
    END IF;

    IF :new.NAME IS NOT NULL THEN
        SELECT COUNT(*) INTO flag FROM GROUPS WHERE NAME = :new.NAME;
        IF flag > 0 THEN
            raise name_taken;
        END IF;
    END IF;
END;

INSERT INTO GROUPS(ID, name, C_VAL)
VALUES (0, 'first', 0);
INSERT INTO GROUPS(ID, name, C_VAL)
VALUES (0, 'second', 0);
INSERT INTO GROUPS(ID, name, C_VAL)
VALUES (0, 'third', 0);
INSERT INTO GROUPS(ID, name, C_VAL)
VALUES (0, 'first', 0);

SELECT *
FROM GROUPS;

INSERT INTO STUDENTS(name, GROUP_ID)
VALUES ('ABOBA1', 1);
INSERT INTO STUDENTS(name, GROUP_ID)
VALUES ('ABOBA2', 2);
INSERT INTO STUDENTS(name, GROUP_ID)
VALUES ('ABOBA3', 3);
INSERT INTO STUDENTS(name, GROUP_ID)
VALUES ('ABOBA4', 2);


DELETE
FROM GROUPS
WHERE ID = 2;

SELECT *
FROM GROUPS;

SELECT *
FROM STUDENTS;
------------
CREATE OR REPLACE TRIGGER GROUP_DEL
    BEFORE DELETE
    ON GROUPS
    FOR EACH ROW
BEGIN
    DELETE FROM Students WHERE GROUP_ID = :old.ID;
END;

DROP TRIGGER STUDENT_DEL;
CREATE OR REPLACE TRIGGER STUDENT_DEL
    BEFORE DELETE
    ON STUDENTS
    FOR EACH ROW
DECLARE
    PRAGMA AUTONOMOUS_TRANSACTION;
    recursive INTEGER := 0;
BEGIN
    SELECT COUNT(*)
    INTO recursive
    FROM user_triggers
    WHERE trigger_name = 'GROUP_DEL'
      AND triggering_event = 'DELETE'
      AND status = 'ENABLED';

    IF recursive = 0 THEN
        DELETE FROM GROUPS WHERE ID = :old.GROUP_ID;
        COMMIT;
    END IF;
END;

INSERT INTO STUDENTS(ID, name, GROUP_ID)
VALUES (0, 'asfa', 4);

SELECT *
FROM GROUPS;
SELECT *
FROM STUDENTS;

DELETE
FROM STUDENTS
WHERE ID = 1;
-----------
DROP TABLE LOGS;

CREATE TABLE LOGS
(
    TIME        TIMESTAMP     NOT NULL,
    MESSAGE     VARCHAR2(100) NOT NULL,
    ST_ID       NUMBER,
    ST_ID_OLD   NUMBER,
    ST_NAME     VARCHAR2(100),
    ST_GROUP_ID NUMBER
);

CREATE OR REPLACE TRIGGER logging
    AFTER INSERT OR DELETE OR UPDATE
    ON STUDENTS
    FOR EACH ROW
BEGIN
    CASE
        WHEN INSERTING THEN INSERT INTO LOGS VALUES (SYSTIMESTAMP, 'INSERT', :new.ID, null, null, null);
        WHEN UPDATING THEN INSERT INTO LOGS VALUES (SYSTIMESTAMP, 'UPDATE', :new.ID, :old.ID, :old.NAME, :old.GROUP_ID);
        WHEN DELETING THEN INSERT INTO LOGS VALUES (SYSTIMESTAMP, 'DELETE', null, :old.ID, :old.NAME, :old.GROUP_ID);
        END CASE;
END;
---------
CREATE OR REPLACE PROCEDURE GO_BACK(restore_time TIMESTAMP)
    IS
    CURSOR s_logs IS
        SELECT *
        FROM LOGS
        WHERE TIME >= restore_time
        ORDER BY TIME DESC;
    temp NUMBER;
    invalid_log EXCEPTION;
BEGIN
    FOR log IN s_logs
        LOOP
            CASE
                WHEN log.MESSAGE = 'INSERT' THEN DELETE FROM STUDENTS WHERE ID = log.ST_ID;
                WHEN log.MESSAGE = 'UPDATE' THEN UPDATE STUDENTS
                                                 SET ID=log.ST_ID_OLD,
                                                     NAME=log.ST_NAME,
                                                     GROUP_ID =log.ST_GROUP_ID
                                                 WHERE ID = log.ST_ID;
                WHEN log.MESSAGE = 'DELETE'
                    THEN INSERT INTO STUDENTS
                         VALUES (log.ST_ID_OLD, log.ST_NAME, log.ST_GROUP_ID)
                         returning STUDENTS.ID into temp;
                         UPDATE STUDENTS
                         SET ID=log.ST_ID_OLD
                         WHERE ID = temp;
                ELSE raise invalid_log;
                END CASE;
            DELETE FROM LOGS WHERE TIME = log.TIME;
        END LOOP;
END GO_BACK;

CREATE OR REPLACE PROCEDURE GO_BACK_OFFSET(offset IN INTERVAL DAY TO SECOND)
    IS
BEGIN
    GO_BACK(LOCALTIMESTAMP - offset);
END GO_BACK_OFFSET;

INSERT INTO STUDENTS(name, GROUP_ID)
VALUES ('asfa', 1);

UPDATE STUDENTS
SET NAME='gdrst',
    GROUP_ID=2
WHERE ID = 11;

DELETE
FROM STUDENTS
WHERE ID = 11;

DELETE
FROM LOGS;
SELECT *
FROM LOGS;
SELECT *
FROM STUDENTS;
BEGIN
    GO_BACK(TO_TIMESTAMP('10.03.2023 14:40:00'));
END;
-----------
DROP TRIGGER UPDATE_GROUPS;
CREATE OR REPLACE TRIGGER UPDATE_GROUPS
    AFTER INSERT OR DELETE OR UPDATE
    ON STUDENTS
    FOR EACH ROW
BEGIN
    CASE
        WHEN INSERTING THEN UPDATE GROUPS
                            SET C_VAL=C_VAL + 1
                            WHERE ID = :new.GROUP_ID;
        WHEN UPDATING THEN UPDATE GROUPS
                           SET C_VAL=C_VAL + 1
                           WHERE ID = :new.GROUP_ID;
                           UPDATE GROUPS
                           SET C_VAL=C_VAL - 1
                           WHERE ID = :old.GROUP_ID;
        WHEN DELETING THEN UPDATE GROUPS
                           SET C_VAL=C_VAL - 1
                           WHERE ID = :old.GROUP_ID;
        END CASE;
END;
